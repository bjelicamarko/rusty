/// Generated by rustemo. Do not edit manually!
use std::fmt::Debug;
use std::hash::Hash;
use rustemo::{
    Result, Input as InputT, Lexer, Token, TokenRecognizer as TokenRecognizerT, Parser,
    ParserDefinition, State as StateT, Builder,
};
use regex::Regex;
use once_cell::sync::Lazy;
use rustemo::StringLexer;
use rustemo::LRBuilder;
use std::cell::RefCell;
use rustemo::{LRParser, LRContext};
use rustemo::Action::{self, Shift, Reduce, Accept};
#[allow(unused_imports)]
use rustemo::debug::{log, logn};
#[allow(unused_imports)]
#[cfg(debug_assertions)]
use colored::*;
pub type Input = str;
const STATE_COUNT: usize = 87usize;
const MAX_RECOGNIZERS: usize = 15usize;
#[allow(dead_code)]
const TERMINAL_COUNT: usize = 31usize;
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TokenKind {
    #[default]
    STOP,
    Number,
    Plus,
    Minus,
    Mul,
    Div,
    True,
    False,
    OpenParenthesis,
    CloseParenthesis,
    Bang,
    EqualsEquals,
    BangEquals,
    Less,
    LessOrEquals,
    Greater,
    GreaterOrEquals,
    AmpersandAmpersand,
    PipePipe,
    Identifier,
    OpenBrace,
    CloseBrace,
    Equals,
    SemiColon,
    If,
    Else,
    Let,
    Const,
    While,
    For,
    To,
}
use TokenKind as TK;
impl From<TokenKind> for usize {
    fn from(t: TokenKind) -> Self {
        t as usize
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Copy, PartialEq)]
pub enum ProdKind {
    ProgramP1,
    StatementListP1,
    Statement1P1,
    Statement1P2,
    StatementP1,
    StatementP2,
    StatementP3,
    StatementP4,
    StatementP5,
    StatementP6,
    StatementP7,
    AssignmentAssignment,
    IfStatementIfStatement,
    ElseClauseOptP1,
    ElseClauseOptP2,
    ElseClauseElseStatement,
    VariableDeclarationVariableDeclaration,
    ConstantDeclarationConstantDeclaration,
    WhileStatementWhile,
    ForStatementFor,
    ExpressionAdd,
    ExpressionSub,
    ExpressionMul,
    ExpressionDiv,
    ExpressionEquals,
    ExpressionNotEquals,
    ExpressionLess,
    ExpressionLessOrEquals,
    ExpressionGreater,
    ExpressionGreaterOrEquals,
    ExpressionAnd,
    ExpressionOr,
    ExpressionUnaryMinus,
    ExpressionUnaryNegation,
    ExpressionP15,
    ExpressionP16,
    ExpressionP17,
    ExpressionP18,
    ExpressionP19,
}
use ProdKind as PK;
impl std::fmt::Debug for ProdKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            ProdKind::ProgramP1 => "Program: StatementList",
            ProdKind::StatementListP1 => "StatementList: OpenBrace Statement1 CloseBrace",
            ProdKind::Statement1P1 => "Statement1: Statement1 Statement",
            ProdKind::Statement1P2 => "Statement1: Statement",
            ProdKind::StatementP1 => "Statement: Assignment",
            ProdKind::StatementP2 => "Statement: IfStatement",
            ProdKind::StatementP3 => "Statement: VariableDeclaration",
            ProdKind::StatementP4 => "Statement: ConstantDeclaration",
            ProdKind::StatementP5 => "Statement: WhileStatement",
            ProdKind::StatementP6 => "Statement: ForStatement",
            ProdKind::StatementP7 => "Statement: StatementList",
            ProdKind::AssignmentAssignment => {
                "Assignment: Identifier Equals Expression SemiColon"
            }
            ProdKind::IfStatementIfStatement => {
                "IfStatement: If OpenParenthesis Expression CloseParenthesis StatementList ElseClauseOpt"
            }
            ProdKind::ElseClauseOptP1 => "ElseClauseOpt: ElseClause",
            ProdKind::ElseClauseOptP2 => "ElseClauseOpt: ",
            ProdKind::ElseClauseElseStatement => "ElseClause: Else StatementList",
            ProdKind::VariableDeclarationVariableDeclaration => {
                "VariableDeclaration: Let Identifier Equals Expression SemiColon"
            }
            ProdKind::ConstantDeclarationConstantDeclaration => {
                "ConstantDeclaration: Const Identifier Equals Expression SemiColon"
            }
            ProdKind::WhileStatementWhile => {
                "WhileStatement: While OpenParenthesis Expression CloseParenthesis StatementList"
            }
            ProdKind::ForStatementFor => {
                "ForStatement: For OpenParenthesis Identifier Equals Expression To Expression CloseParenthesis StatementList"
            }
            ProdKind::ExpressionAdd => "Expression: Expression Plus Expression",
            ProdKind::ExpressionSub => "Expression: Expression Minus Expression",
            ProdKind::ExpressionMul => "Expression: Expression Mul Expression",
            ProdKind::ExpressionDiv => "Expression: Expression Div Expression",
            ProdKind::ExpressionEquals => {
                "Expression: Expression EqualsEquals Expression"
            }
            ProdKind::ExpressionNotEquals => {
                "Expression: Expression BangEquals Expression"
            }
            ProdKind::ExpressionLess => "Expression: Expression Less Expression",
            ProdKind::ExpressionLessOrEquals => {
                "Expression: Expression LessOrEquals Expression"
            }
            ProdKind::ExpressionGreater => "Expression: Expression Greater Expression",
            ProdKind::ExpressionGreaterOrEquals => {
                "Expression: Expression GreaterOrEquals Expression"
            }
            ProdKind::ExpressionAnd => {
                "Expression: Expression AmpersandAmpersand Expression"
            }
            ProdKind::ExpressionOr => "Expression: Expression PipePipe Expression",
            ProdKind::ExpressionUnaryMinus => "Expression: Minus Expression",
            ProdKind::ExpressionUnaryNegation => "Expression: Bang Expression",
            ProdKind::ExpressionP15 => {
                "Expression: OpenParenthesis Expression CloseParenthesis"
            }
            ProdKind::ExpressionP16 => "Expression: Number",
            ProdKind::ExpressionP17 => "Expression: True",
            ProdKind::ExpressionP18 => "Expression: False",
            ProdKind::ExpressionP19 => "Expression: Identifier",
        };
        write!(f, "{}", name)
    }
}
#[allow(clippy::upper_case_acronyms)]
#[allow(dead_code)]
#[derive(Clone, Copy, Debug)]
pub enum NonTermKind {
    EMPTY,
    AUG,
    Program,
    StatementList,
    Statement1,
    Statement,
    Assignment,
    IfStatement,
    ElseClauseOpt,
    ElseClause,
    VariableDeclaration,
    ConstantDeclaration,
    WhileStatement,
    ForStatement,
    Expression,
}
impl From<ProdKind> for NonTermKind {
    fn from(prod: ProdKind) -> Self {
        match prod {
            ProdKind::ProgramP1 => NonTermKind::Program,
            ProdKind::StatementListP1 => NonTermKind::StatementList,
            ProdKind::Statement1P1 => NonTermKind::Statement1,
            ProdKind::Statement1P2 => NonTermKind::Statement1,
            ProdKind::StatementP1 => NonTermKind::Statement,
            ProdKind::StatementP2 => NonTermKind::Statement,
            ProdKind::StatementP3 => NonTermKind::Statement,
            ProdKind::StatementP4 => NonTermKind::Statement,
            ProdKind::StatementP5 => NonTermKind::Statement,
            ProdKind::StatementP6 => NonTermKind::Statement,
            ProdKind::StatementP7 => NonTermKind::Statement,
            ProdKind::AssignmentAssignment => NonTermKind::Assignment,
            ProdKind::IfStatementIfStatement => NonTermKind::IfStatement,
            ProdKind::ElseClauseOptP1 => NonTermKind::ElseClauseOpt,
            ProdKind::ElseClauseOptP2 => NonTermKind::ElseClauseOpt,
            ProdKind::ElseClauseElseStatement => NonTermKind::ElseClause,
            ProdKind::VariableDeclarationVariableDeclaration => {
                NonTermKind::VariableDeclaration
            }
            ProdKind::ConstantDeclarationConstantDeclaration => {
                NonTermKind::ConstantDeclaration
            }
            ProdKind::WhileStatementWhile => NonTermKind::WhileStatement,
            ProdKind::ForStatementFor => NonTermKind::ForStatement,
            ProdKind::ExpressionAdd => NonTermKind::Expression,
            ProdKind::ExpressionSub => NonTermKind::Expression,
            ProdKind::ExpressionMul => NonTermKind::Expression,
            ProdKind::ExpressionDiv => NonTermKind::Expression,
            ProdKind::ExpressionEquals => NonTermKind::Expression,
            ProdKind::ExpressionNotEquals => NonTermKind::Expression,
            ProdKind::ExpressionLess => NonTermKind::Expression,
            ProdKind::ExpressionLessOrEquals => NonTermKind::Expression,
            ProdKind::ExpressionGreater => NonTermKind::Expression,
            ProdKind::ExpressionGreaterOrEquals => NonTermKind::Expression,
            ProdKind::ExpressionAnd => NonTermKind::Expression,
            ProdKind::ExpressionOr => NonTermKind::Expression,
            ProdKind::ExpressionUnaryMinus => NonTermKind::Expression,
            ProdKind::ExpressionUnaryNegation => NonTermKind::Expression,
            ProdKind::ExpressionP15 => NonTermKind::Expression,
            ProdKind::ExpressionP16 => NonTermKind::Expression,
            ProdKind::ExpressionP17 => NonTermKind::Expression,
            ProdKind::ExpressionP18 => NonTermKind::Expression,
            ProdKind::ExpressionP19 => NonTermKind::Expression,
        }
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    #[default]
    AUGS0,
    OpenBraceS1,
    ProgramS2,
    StatementListS3,
    IdentifierS4,
    IfS5,
    LetS6,
    ConstS7,
    WhileS8,
    ForS9,
    StatementListS10,
    Statement1S11,
    StatementS12,
    AssignmentS13,
    IfStatementS14,
    VariableDeclarationS15,
    ConstantDeclarationS16,
    WhileStatementS17,
    ForStatementS18,
    EqualsS19,
    OpenParenthesisS20,
    IdentifierS21,
    IdentifierS22,
    OpenParenthesisS23,
    OpenParenthesisS24,
    CloseBraceS25,
    StatementS26,
    NumberS27,
    MinusS28,
    TrueS29,
    FalseS30,
    OpenParenthesisS31,
    BangS32,
    IdentifierS33,
    ExpressionS34,
    ExpressionS35,
    EqualsS36,
    EqualsS37,
    ExpressionS38,
    IdentifierS39,
    ExpressionS40,
    ExpressionS41,
    ExpressionS42,
    PlusS43,
    MinusS44,
    MulS45,
    DivS46,
    EqualsEqualsS47,
    BangEqualsS48,
    LessS49,
    LessOrEqualsS50,
    GreaterS51,
    GreaterOrEqualsS52,
    AmpersandAmpersandS53,
    PipePipeS54,
    SemiColonS55,
    CloseParenthesisS56,
    ExpressionS57,
    ExpressionS58,
    CloseParenthesisS59,
    EqualsS60,
    CloseParenthesisS61,
    ExpressionS62,
    ExpressionS63,
    ExpressionS64,
    ExpressionS65,
    ExpressionS66,
    ExpressionS67,
    ExpressionS68,
    ExpressionS69,
    ExpressionS70,
    ExpressionS71,
    ExpressionS72,
    ExpressionS73,
    StatementListS74,
    SemiColonS75,
    SemiColonS76,
    StatementListS77,
    ExpressionS78,
    ElseS79,
    ElseClauseOptS80,
    ElseClauseS81,
    ToS82,
    StatementListS83,
    ExpressionS84,
    CloseParenthesisS85,
    StatementListS86,
}
impl StateT for State {
    fn default_layout() -> Option<Self> {
        None
    }
}
impl From<State> for usize {
    fn from(s: State) -> Self {
        s as usize
    }
}
impl std::fmt::Debug for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            State::AUGS0 => "0:AUG",
            State::OpenBraceS1 => "1:OpenBrace",
            State::ProgramS2 => "2:Program",
            State::StatementListS3 => "3:StatementList",
            State::IdentifierS4 => "4:Identifier",
            State::IfS5 => "5:If",
            State::LetS6 => "6:Let",
            State::ConstS7 => "7:Const",
            State::WhileS8 => "8:While",
            State::ForS9 => "9:For",
            State::StatementListS10 => "10:StatementList",
            State::Statement1S11 => "11:Statement1",
            State::StatementS12 => "12:Statement",
            State::AssignmentS13 => "13:Assignment",
            State::IfStatementS14 => "14:IfStatement",
            State::VariableDeclarationS15 => "15:VariableDeclaration",
            State::ConstantDeclarationS16 => "16:ConstantDeclaration",
            State::WhileStatementS17 => "17:WhileStatement",
            State::ForStatementS18 => "18:ForStatement",
            State::EqualsS19 => "19:Equals",
            State::OpenParenthesisS20 => "20:OpenParenthesis",
            State::IdentifierS21 => "21:Identifier",
            State::IdentifierS22 => "22:Identifier",
            State::OpenParenthesisS23 => "23:OpenParenthesis",
            State::OpenParenthesisS24 => "24:OpenParenthesis",
            State::CloseBraceS25 => "25:CloseBrace",
            State::StatementS26 => "26:Statement",
            State::NumberS27 => "27:Number",
            State::MinusS28 => "28:Minus",
            State::TrueS29 => "29:True",
            State::FalseS30 => "30:False",
            State::OpenParenthesisS31 => "31:OpenParenthesis",
            State::BangS32 => "32:Bang",
            State::IdentifierS33 => "33:Identifier",
            State::ExpressionS34 => "34:Expression",
            State::ExpressionS35 => "35:Expression",
            State::EqualsS36 => "36:Equals",
            State::EqualsS37 => "37:Equals",
            State::ExpressionS38 => "38:Expression",
            State::IdentifierS39 => "39:Identifier",
            State::ExpressionS40 => "40:Expression",
            State::ExpressionS41 => "41:Expression",
            State::ExpressionS42 => "42:Expression",
            State::PlusS43 => "43:Plus",
            State::MinusS44 => "44:Minus",
            State::MulS45 => "45:Mul",
            State::DivS46 => "46:Div",
            State::EqualsEqualsS47 => "47:EqualsEquals",
            State::BangEqualsS48 => "48:BangEquals",
            State::LessS49 => "49:Less",
            State::LessOrEqualsS50 => "50:LessOrEquals",
            State::GreaterS51 => "51:Greater",
            State::GreaterOrEqualsS52 => "52:GreaterOrEquals",
            State::AmpersandAmpersandS53 => "53:AmpersandAmpersand",
            State::PipePipeS54 => "54:PipePipe",
            State::SemiColonS55 => "55:SemiColon",
            State::CloseParenthesisS56 => "56:CloseParenthesis",
            State::ExpressionS57 => "57:Expression",
            State::ExpressionS58 => "58:Expression",
            State::CloseParenthesisS59 => "59:CloseParenthesis",
            State::EqualsS60 => "60:Equals",
            State::CloseParenthesisS61 => "61:CloseParenthesis",
            State::ExpressionS62 => "62:Expression",
            State::ExpressionS63 => "63:Expression",
            State::ExpressionS64 => "64:Expression",
            State::ExpressionS65 => "65:Expression",
            State::ExpressionS66 => "66:Expression",
            State::ExpressionS67 => "67:Expression",
            State::ExpressionS68 => "68:Expression",
            State::ExpressionS69 => "69:Expression",
            State::ExpressionS70 => "70:Expression",
            State::ExpressionS71 => "71:Expression",
            State::ExpressionS72 => "72:Expression",
            State::ExpressionS73 => "73:Expression",
            State::StatementListS74 => "74:StatementList",
            State::SemiColonS75 => "75:SemiColon",
            State::SemiColonS76 => "76:SemiColon",
            State::StatementListS77 => "77:StatementList",
            State::ExpressionS78 => "78:Expression",
            State::ElseS79 => "79:Else",
            State::ElseClauseOptS80 => "80:ElseClauseOpt",
            State::ElseClauseS81 => "81:ElseClause",
            State::ToS82 => "82:To",
            State::StatementListS83 => "83:StatementList",
            State::ExpressionS84 => "84:Expression",
            State::CloseParenthesisS85 => "85:CloseParenthesis",
            State::StatementListS86 => "86:StatementList",
        };
        write!(f, "{name}")
    }
}
type ActionFn = fn(token: TokenKind) -> Vec<Action<State, ProdKind>>;
pub struct AnotherParserDefinition {
    actions: [ActionFn; STATE_COUNT],
    gotos: [fn(nonterm: NonTermKind) -> State; STATE_COUNT],
    token_kinds: [[Option<(TokenKind, bool)>; MAX_RECOGNIZERS]; STATE_COUNT],
}
fn action_aug_s0(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_openbrace_s1(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS4)]),
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        TK::If => Vec::from(&[Shift(State::IfS5)]),
        TK::Let => Vec::from(&[Shift(State::LetS6)]),
        TK::Const => Vec::from(&[Shift(State::ConstS7)]),
        TK::While => Vec::from(&[Shift(State::WhileS8)]),
        TK::For => Vec::from(&[Shift(State::ForS9)]),
        _ => vec![],
    }
}
fn action_program_s2(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_statementlist_s3(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ProgramP1, 1usize)]),
        _ => vec![],
    }
}
fn action_identifier_s4(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS19)]),
        _ => vec![],
    }
}
fn action_if_s5(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS20)]),
        _ => vec![],
    }
}
fn action_let_s6(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS21)]),
        _ => vec![],
    }
}
fn action_const_s7(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS22)]),
        _ => vec![],
    }
}
fn action_while_s8(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS23)]),
        _ => vec![],
    }
}
fn action_for_s9(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS24)]),
        _ => vec![],
    }
}
fn action_statementlist_s10(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP7, 1usize)]),
        _ => vec![],
    }
}
fn action_statement1_s11(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS4)]),
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS25)]),
        TK::If => Vec::from(&[Shift(State::IfS5)]),
        TK::Let => Vec::from(&[Shift(State::LetS6)]),
        TK::Const => Vec::from(&[Shift(State::ConstS7)]),
        TK::While => Vec::from(&[Shift(State::WhileS8)]),
        TK::For => Vec::from(&[Shift(State::ForS9)]),
        _ => vec![],
    }
}
fn action_statement_s12(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_assignment_s13(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        _ => vec![],
    }
}
fn action_ifstatement_s14(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        _ => vec![],
    }
}
fn action_variabledeclaration_s15(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        _ => vec![],
    }
}
fn action_constantdeclaration_s16(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        _ => vec![],
    }
}
fn action_whilestatement_s17(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        _ => vec![],
    }
}
fn action_forstatement_s18(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        _ => vec![],
    }
}
fn action_equals_s19(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s20(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_identifier_s21(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS36)]),
        _ => vec![],
    }
}
fn action_identifier_s22(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS37)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s23(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s24(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS39)]),
        _ => vec![],
    }
}
fn action_closebrace_s25(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Identifier => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Else => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        _ => vec![],
    }
}
fn action_statement_s26(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::If => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::Let => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::Const => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::While => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::For => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_number_s27(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        _ => vec![],
    }
}
fn action_minus_s28(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_true_s29(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        _ => vec![],
    }
}
fn action_false_s30(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s31(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_bang_s32(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_identifier_s33(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        _ => vec![],
    }
}
fn action_expression_s34(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS55)]),
        _ => vec![],
    }
}
fn action_expression_s35(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS56)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        _ => vec![],
    }
}
fn action_equals_s36(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_equals_s37(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_expression_s38(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS59)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        _ => vec![],
    }
}
fn action_identifier_s39(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS60)]),
        _ => vec![],
    }
}
fn action_expression_s40(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        _ => vec![],
    }
}
fn action_expression_s41(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS61)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        _ => vec![],
    }
}
fn action_expression_s42(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        _ => vec![],
    }
}
fn action_plus_s43(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_minus_s44(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_mul_s45(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_div_s46(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_equalsequals_s47(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_bangequals_s48(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_less_s49(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_lessorequals_s50(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_greater_s51(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_greaterorequals_s52(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_ampersandampersand_s53(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_pipepipe_s54(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_semicolon_s55(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::If => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::Let => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::Const => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::While => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::For => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s56(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_expression_s57(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS75)]),
        _ => vec![],
    }
}
fn action_expression_s58(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS76)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s59(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_equals_s60(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s61(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s62(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s63(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s64(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s65(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s66(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s67(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s68(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s69(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s70(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s71(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::GreaterOrEquals => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s72(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s73(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        _ => vec![],
    }
}
fn action_statementlist_s74(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::Else => Vec::from(&[Shift(State::ElseS79)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s75(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::OpenBrace => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::CloseBrace => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::If => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::Let => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::Const => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::While => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::For => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        _ => vec![],
    }
}
fn action_semicolon_s76(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::OpenBrace => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::CloseBrace => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::If => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::Let => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::Const => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::While => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::For => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        _ => vec![],
    }
}
fn action_statementlist_s77(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::If => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::Let => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::Const => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::While => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::For => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        _ => vec![],
    }
}
fn action_expression_s78(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        TK::To => Vec::from(&[Shift(State::ToS82)]),
        _ => vec![],
    }
}
fn action_else_s79(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_elseclauseopt_s80(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::If => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::Let => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::Const => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::While => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::For => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        _ => vec![],
    }
}
fn action_elseclause_s81(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_to_s82(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS27)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS28)]),
        TK::True => Vec::from(&[Shift(State::TrueS29)]),
        TK::False => Vec::from(&[Shift(State::FalseS30)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS31)]),
        TK::Bang => Vec::from(&[Shift(State::BangS32)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS33)]),
        _ => vec![],
    }
}
fn action_statementlist_s83(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        _ => vec![],
    }
}
fn action_expression_s84(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS43)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS44)]),
        TK::Mul => Vec::from(&[Shift(State::MulS45)]),
        TK::Div => Vec::from(&[Shift(State::DivS46)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS85)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS47)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS48)]),
        TK::Less => Vec::from(&[Shift(State::LessS49)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS50)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS51)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS52)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS53)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS54)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s85(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_statementlist_s86(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::OpenBrace => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::If => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::While => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::For => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        _ => vec![],
    }
}
fn goto_aug_s0(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Program => State::ProgramS2,
        NonTermKind::StatementList => State::StatementListS3,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGS0
            )
        }
    }
}
fn goto_openbrace_s1(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS10,
        NonTermKind::Statement1 => State::Statement1S11,
        NonTermKind::Statement => State::StatementS12,
        NonTermKind::Assignment => State::AssignmentS13,
        NonTermKind::IfStatement => State::IfStatementS14,
        NonTermKind::VariableDeclaration => State::VariableDeclarationS15,
        NonTermKind::ConstantDeclaration => State::ConstantDeclarationS16,
        NonTermKind::WhileStatement => State::WhileStatementS17,
        NonTermKind::ForStatement => State::ForStatementS18,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS1
            )
        }
    }
}
fn goto_statement1_s11(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS10,
        NonTermKind::Statement => State::StatementS26,
        NonTermKind::Assignment => State::AssignmentS13,
        NonTermKind::IfStatement => State::IfStatementS14,
        NonTermKind::VariableDeclaration => State::VariableDeclarationS15,
        NonTermKind::ConstantDeclaration => State::ConstantDeclarationS16,
        NonTermKind::WhileStatement => State::WhileStatementS17,
        NonTermKind::ForStatement => State::ForStatementS18,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Statement1S11
            )
        }
    }
}
fn goto_equals_s19(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS34,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS19
            )
        }
    }
}
fn goto_openparenthesis_s20(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS35,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS20
            )
        }
    }
}
fn goto_openparenthesis_s23(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS38,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS23
            )
        }
    }
}
fn goto_minus_s28(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MinusS28
            )
        }
    }
}
fn goto_openparenthesis_s31(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS41,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS31
            )
        }
    }
}
fn goto_bang_s32(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS42,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::BangS32
            )
        }
    }
}
fn goto_equals_s36(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS57,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS36
            )
        }
    }
}
fn goto_equals_s37(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS58,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS37
            )
        }
    }
}
fn goto_plus_s43(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS62,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PlusS43
            )
        }
    }
}
fn goto_minus_s44(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS63,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MinusS44
            )
        }
    }
}
fn goto_mul_s45(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS64,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MulS45
            )
        }
    }
}
fn goto_div_s46(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS65,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::DivS46
            )
        }
    }
}
fn goto_equalsequals_s47(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS66,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsEqualsS47
            )
        }
    }
}
fn goto_bangequals_s48(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS67,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::BangEqualsS48
            )
        }
    }
}
fn goto_less_s49(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS68,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::LessS49
            )
        }
    }
}
fn goto_lessorequals_s50(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS69,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::LessOrEqualsS50
            )
        }
    }
}
fn goto_greater_s51(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS70,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GreaterS51
            )
        }
    }
}
fn goto_greaterorequals_s52(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS71,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GreaterOrEqualsS52
            )
        }
    }
}
fn goto_ampersandampersand_s53(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS72,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AmpersandAmpersandS53
            )
        }
    }
}
fn goto_pipepipe_s54(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS73,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PipePipeS54
            )
        }
    }
}
fn goto_closeparenthesis_s56(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS74,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS56
            )
        }
    }
}
fn goto_closeparenthesis_s59(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS77,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS59
            )
        }
    }
}
fn goto_equals_s60(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS78,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS60
            )
        }
    }
}
fn goto_statementlist_s74(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ElseClauseOpt => State::ElseClauseOptS80,
        NonTermKind::ElseClause => State::ElseClauseS81,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::StatementListS74
            )
        }
    }
}
fn goto_else_s79(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS83,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ElseS79
            )
        }
    }
}
fn goto_to_s82(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS84,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ToS82
            )
        }
    }
}
fn goto_closeparenthesis_s85(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS86,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS85
            )
        }
    }
}
fn goto_invalid(_nonterm_kind: NonTermKind) -> State {
    panic!("Invalid GOTO entry!");
}
pub(crate) static PARSER_DEFINITION: AnotherParserDefinition = AnotherParserDefinition {
    actions: [
        action_aug_s0,
        action_openbrace_s1,
        action_program_s2,
        action_statementlist_s3,
        action_identifier_s4,
        action_if_s5,
        action_let_s6,
        action_const_s7,
        action_while_s8,
        action_for_s9,
        action_statementlist_s10,
        action_statement1_s11,
        action_statement_s12,
        action_assignment_s13,
        action_ifstatement_s14,
        action_variabledeclaration_s15,
        action_constantdeclaration_s16,
        action_whilestatement_s17,
        action_forstatement_s18,
        action_equals_s19,
        action_openparenthesis_s20,
        action_identifier_s21,
        action_identifier_s22,
        action_openparenthesis_s23,
        action_openparenthesis_s24,
        action_closebrace_s25,
        action_statement_s26,
        action_number_s27,
        action_minus_s28,
        action_true_s29,
        action_false_s30,
        action_openparenthesis_s31,
        action_bang_s32,
        action_identifier_s33,
        action_expression_s34,
        action_expression_s35,
        action_equals_s36,
        action_equals_s37,
        action_expression_s38,
        action_identifier_s39,
        action_expression_s40,
        action_expression_s41,
        action_expression_s42,
        action_plus_s43,
        action_minus_s44,
        action_mul_s45,
        action_div_s46,
        action_equalsequals_s47,
        action_bangequals_s48,
        action_less_s49,
        action_lessorequals_s50,
        action_greater_s51,
        action_greaterorequals_s52,
        action_ampersandampersand_s53,
        action_pipepipe_s54,
        action_semicolon_s55,
        action_closeparenthesis_s56,
        action_expression_s57,
        action_expression_s58,
        action_closeparenthesis_s59,
        action_equals_s60,
        action_closeparenthesis_s61,
        action_expression_s62,
        action_expression_s63,
        action_expression_s64,
        action_expression_s65,
        action_expression_s66,
        action_expression_s67,
        action_expression_s68,
        action_expression_s69,
        action_expression_s70,
        action_expression_s71,
        action_expression_s72,
        action_expression_s73,
        action_statementlist_s74,
        action_semicolon_s75,
        action_semicolon_s76,
        action_statementlist_s77,
        action_expression_s78,
        action_else_s79,
        action_elseclauseopt_s80,
        action_elseclause_s81,
        action_to_s82,
        action_statementlist_s83,
        action_expression_s84,
        action_closeparenthesis_s85,
        action_statementlist_s86,
    ],
    gotos: [
        goto_aug_s0,
        goto_openbrace_s1,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_statement1_s11,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_equals_s19,
        goto_openparenthesis_s20,
        goto_invalid,
        goto_invalid,
        goto_openparenthesis_s23,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_minus_s28,
        goto_invalid,
        goto_invalid,
        goto_openparenthesis_s31,
        goto_bang_s32,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_equals_s36,
        goto_equals_s37,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_plus_s43,
        goto_minus_s44,
        goto_mul_s45,
        goto_div_s46,
        goto_equalsequals_s47,
        goto_bangequals_s48,
        goto_less_s49,
        goto_lessorequals_s50,
        goto_greater_s51,
        goto_greaterorequals_s52,
        goto_ampersandampersand_s53,
        goto_pipepipe_s54,
        goto_invalid,
        goto_closeparenthesis_s56,
        goto_invalid,
        goto_invalid,
        goto_closeparenthesis_s59,
        goto_equals_s60,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_statementlist_s74,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_else_s79,
        goto_invalid,
        goto_invalid,
        goto_to_s82,
        goto_invalid,
        goto_invalid,
        goto_closeparenthesis_s85,
        goto_invalid,
    ],
    token_kinds: [
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Else, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Else, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::OpenBrace, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
    ],
};
impl ParserDefinition<State, ProdKind, TokenKind, NonTermKind>
for AnotherParserDefinition {
    fn actions(&self, state: State, token: TokenKind) -> Vec<Action<State, ProdKind>> {
        PARSER_DEFINITION.actions[state as usize](token)
    }
    fn goto(&self, state: State, nonterm: NonTermKind) -> State {
        PARSER_DEFINITION.gotos[state as usize](nonterm)
    }
    fn expected_token_kinds(&self, state: State) -> Vec<(TokenKind, bool)> {
        PARSER_DEFINITION.token_kinds[state as usize].iter().map_while(|t| *t).collect()
    }
    fn longest_match() -> bool {
        true
    }
    fn grammar_order() -> bool {
        true
    }
}
pub(crate) type Context<'i, I> = LRContext<'i, I, State, TokenKind>;
pub struct AnotherParser<
    'i,
    I: InputT + ?Sized,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B,
>(
    LRParser<
        'i,
        Context<'i, I>,
        State,
        ProdKind,
        TokenKind,
        NonTermKind,
        AnotherParserDefinition,
        L,
        B,
        I,
    >,
);
#[allow(dead_code)]
impl<
    'i,
    B,
> AnotherParser<
    'i,
    Input,
    StringLexer<Context<'i, Input>, State, TokenKind, TokenRecognizer, TERMINAL_COUNT>,
    B,
>
where
    B: LRBuilder<'i, Input, Context<'i, Input>, State, ProdKind, TokenKind>,
{
    pub fn new(builder: B) -> Self {
        Self(
            LRParser::new(
                &PARSER_DEFINITION,
                State::default(),
                false,
                false,
                StringLexer::new(true, &RECOGNIZERS),
                builder,
            ),
        )
    }
}
#[allow(dead_code)]
impl<'i, I, L, B> Parser<'i, I, Context<'i, I>, State, TokenKind>
for AnotherParser<'i, I, L, B>
where
    I: InputT + ?Sized + Debug,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B: LRBuilder<'i, I, Context<'i, I>, State, ProdKind, TokenKind>,
{
    type Output = B::Output;
    fn parse(&self, input: &'i I) -> Result<Self::Output> {
        self.0.parse(input)
    }
    fn parse_with_context(
        &self,
        context: &mut Context<'i, I>,
        input: &'i I,
    ) -> Result<Self::Output> {
        self.0.parse_with_context(context, input)
    }
    fn parse_file<'a, F: AsRef<std::path::Path>>(
        &'a mut self,
        file: F,
    ) -> Result<Self::Output>
    where
        'a: 'i,
    {
        self.0.parse_file(file)
    }
}
#[allow(dead_code)]
#[derive(Debug)]
pub enum Recognizer {
    Stop,
    StrMatch(&'static str),
    RegexMatch(Lazy<Regex>),
}
#[allow(dead_code)]
#[derive(Debug)]
pub struct TokenRecognizer(TokenKind, Recognizer);
impl<'i> TokenRecognizerT<'i> for TokenRecognizer {
    fn recognize(&self, input: &'i str) -> Option<&'i str> {
        match &self {
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::StrMatch(s)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                if input.starts_with(s) {
                    log!("{}", "recognized".bold().green());
                    Some(s)
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::RegexMatch(r)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                let match_str = r.find(input);
                match match_str {
                    Some(x) => {
                        let x_str = x.as_str();
                        log!("{} '{}'", "recognized".bold().green(), x_str);
                        Some(x_str)
                    }
                    _ => {
                        log!("{}", "not recognized".red());
                        None
                    }
                }
            }
            TokenRecognizer(_, Recognizer::Stop) => {
                logn!("{} STOP -- ", "    Recognizing".green());
                if input.is_empty() {
                    log!("{}", "recognized".bold().green());
                    Some("")
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
        }
    }
}
pub(crate) static RECOGNIZERS: [TokenRecognizer; TERMINAL_COUNT] = [
    TokenRecognizer(TokenKind::STOP, Recognizer::Stop),
    TokenRecognizer(
        TokenKind::Number,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "\\d+(\\.\\d+)?")).unwrap() }),
        ),
    ),
    TokenRecognizer(TokenKind::Plus, Recognizer::StrMatch("+")),
    TokenRecognizer(TokenKind::Minus, Recognizer::StrMatch("-")),
    TokenRecognizer(TokenKind::Mul, Recognizer::StrMatch("*")),
    TokenRecognizer(TokenKind::Div, Recognizer::StrMatch("/")),
    TokenRecognizer(TokenKind::True, Recognizer::StrMatch("true")),
    TokenRecognizer(TokenKind::False, Recognizer::StrMatch("false")),
    TokenRecognizer(TokenKind::OpenParenthesis, Recognizer::StrMatch("(")),
    TokenRecognizer(TokenKind::CloseParenthesis, Recognizer::StrMatch(")")),
    TokenRecognizer(TokenKind::Bang, Recognizer::StrMatch("!")),
    TokenRecognizer(TokenKind::EqualsEquals, Recognizer::StrMatch("==")),
    TokenRecognizer(TokenKind::BangEquals, Recognizer::StrMatch("!=")),
    TokenRecognizer(TokenKind::Less, Recognizer::StrMatch("<")),
    TokenRecognizer(TokenKind::LessOrEquals, Recognizer::StrMatch("<=")),
    TokenRecognizer(TokenKind::Greater, Recognizer::StrMatch(">")),
    TokenRecognizer(TokenKind::GreaterOrEquals, Recognizer::StrMatch(">=")),
    TokenRecognizer(TokenKind::AmpersandAmpersand, Recognizer::StrMatch("&&")),
    TokenRecognizer(TokenKind::PipePipe, Recognizer::StrMatch("||")),
    TokenRecognizer(
        TokenKind::Identifier,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z_]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(TokenKind::OpenBrace, Recognizer::StrMatch("{")),
    TokenRecognizer(TokenKind::CloseBrace, Recognizer::StrMatch("}")),
    TokenRecognizer(TokenKind::Equals, Recognizer::StrMatch("=")),
    TokenRecognizer(TokenKind::SemiColon, Recognizer::StrMatch(";")),
    TokenRecognizer(TokenKind::If, Recognizer::StrMatch("if")),
    TokenRecognizer(TokenKind::Else, Recognizer::StrMatch("else")),
    TokenRecognizer(TokenKind::Let, Recognizer::StrMatch("let")),
    TokenRecognizer(TokenKind::Const, Recognizer::StrMatch("const")),
    TokenRecognizer(TokenKind::While, Recognizer::StrMatch("while")),
    TokenRecognizer(TokenKind::For, Recognizer::StrMatch("for")),
    TokenRecognizer(TokenKind::To, Recognizer::StrMatch("to")),
];
