/// Generated by rustemo. Do not edit manually!
use std::fmt::Debug;
use std::hash::Hash;
use rustemo::{
    Result, Input as InputT, Lexer, Token, TokenRecognizer as TokenRecognizerT, Parser,
    ParserDefinition, State as StateT, Builder,
};
use regex::Regex;
use once_cell::sync::Lazy;
use rustemo::StringLexer;
use rustemo::LRBuilder;
use super::compiler_actions;
use rustemo::{LRParser, LRContext};
use rustemo::Action::{self, Shift, Reduce, Accept};
#[allow(unused_imports)]
use rustemo::debug::{log, logn};
#[allow(unused_imports)]
#[cfg(debug_assertions)]
use colored::*;
pub type Input = str;
const STATE_COUNT: usize = 86usize;
const MAX_RECOGNIZERS: usize = 15usize;
#[allow(dead_code)]
const TERMINAL_COUNT: usize = 31usize;
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TokenKind {
    #[default]
    STOP,
    Number,
    Plus,
    Minus,
    Mul,
    Div,
    True,
    False,
    OpenParenthesis,
    CloseParenthesis,
    Bang,
    EqualsEquals,
    BangEquals,
    Less,
    LessOrEquals,
    Greater,
    GreaterOrEquals,
    AmpersandAmpersand,
    PipePipe,
    Identifier,
    OpenBrace,
    CloseBrace,
    Equals,
    SemiColon,
    If,
    Else,
    Let,
    Const,
    While,
    For,
    To,
}
use TokenKind as TK;
impl From<TokenKind> for usize {
    fn from(t: TokenKind) -> Self {
        t as usize
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Copy, PartialEq)]
pub enum ProdKind {
    ProgramP1,
    StatementListP1,
    Statement1P1,
    Statement1P2,
    StatementP1,
    StatementP2,
    StatementP3,
    StatementP4,
    StatementP5,
    StatementP6,
    AssignmentAssignment,
    IfStatementIfStatement,
    ElseClauseOptP1,
    ElseClauseOptP2,
    ElseClauseElseStatement,
    VariableDeclarationVariableDeclaration,
    ConstantDeclarationConstantDeclaration,
    WhileStatementWhile,
    ForStatementFor,
    ExpressionAdd,
    ExpressionSub,
    ExpressionMul,
    ExpressionDiv,
    ExpressionEquals,
    ExpressionNotEquals,
    ExpressionLess,
    ExpressionLessOrEquals,
    ExpressionGreater,
    ExpressionGreaterOrEquals,
    ExpressionAnd,
    ExpressionOr,
    ExpressionUnaryMinus,
    ExpressionUnaryNegation,
    ExpressionP15,
    ExpressionP16,
    ExpressionP17,
    ExpressionP18,
    ExpressionP19,
}
use ProdKind as PK;
impl std::fmt::Debug for ProdKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            ProdKind::ProgramP1 => "Program: StatementList",
            ProdKind::StatementListP1 => "StatementList: OpenBrace Statement1 CloseBrace",
            ProdKind::Statement1P1 => "Statement1: Statement1 Statement",
            ProdKind::Statement1P2 => "Statement1: Statement",
            ProdKind::StatementP1 => "Statement: Assignment",
            ProdKind::StatementP2 => "Statement: IfStatement",
            ProdKind::StatementP3 => "Statement: VariableDeclaration",
            ProdKind::StatementP4 => "Statement: ConstantDeclaration",
            ProdKind::StatementP5 => "Statement: WhileStatement",
            ProdKind::StatementP6 => "Statement: ForStatement",
            ProdKind::AssignmentAssignment => {
                "Assignment: Identifier Equals Expression SemiColon"
            }
            ProdKind::IfStatementIfStatement => {
                "IfStatement: If OpenParenthesis Expression CloseParenthesis StatementList ElseClauseOpt"
            }
            ProdKind::ElseClauseOptP1 => "ElseClauseOpt: ElseClause",
            ProdKind::ElseClauseOptP2 => "ElseClauseOpt: ",
            ProdKind::ElseClauseElseStatement => "ElseClause: Else StatementList",
            ProdKind::VariableDeclarationVariableDeclaration => {
                "VariableDeclaration: Let Identifier Equals Expression SemiColon"
            }
            ProdKind::ConstantDeclarationConstantDeclaration => {
                "ConstantDeclaration: Const Identifier Equals Expression SemiColon"
            }
            ProdKind::WhileStatementWhile => {
                "WhileStatement: While OpenParenthesis Expression CloseParenthesis StatementList"
            }
            ProdKind::ForStatementFor => {
                "ForStatement: For OpenParenthesis Identifier Equals Expression To Expression CloseParenthesis StatementList"
            }
            ProdKind::ExpressionAdd => "Expression: Expression Plus Expression",
            ProdKind::ExpressionSub => "Expression: Expression Minus Expression",
            ProdKind::ExpressionMul => "Expression: Expression Mul Expression",
            ProdKind::ExpressionDiv => "Expression: Expression Div Expression",
            ProdKind::ExpressionEquals => {
                "Expression: Expression EqualsEquals Expression"
            }
            ProdKind::ExpressionNotEquals => {
                "Expression: Expression BangEquals Expression"
            }
            ProdKind::ExpressionLess => "Expression: Expression Less Expression",
            ProdKind::ExpressionLessOrEquals => {
                "Expression: Expression LessOrEquals Expression"
            }
            ProdKind::ExpressionGreater => "Expression: Expression Greater Expression",
            ProdKind::ExpressionGreaterOrEquals => {
                "Expression: Expression GreaterOrEquals Expression"
            }
            ProdKind::ExpressionAnd => {
                "Expression: Expression AmpersandAmpersand Expression"
            }
            ProdKind::ExpressionOr => "Expression: Expression PipePipe Expression",
            ProdKind::ExpressionUnaryMinus => "Expression: Minus Expression",
            ProdKind::ExpressionUnaryNegation => "Expression: Bang Expression",
            ProdKind::ExpressionP15 => {
                "Expression: OpenParenthesis Expression CloseParenthesis"
            }
            ProdKind::ExpressionP16 => "Expression: Number",
            ProdKind::ExpressionP17 => "Expression: True",
            ProdKind::ExpressionP18 => "Expression: False",
            ProdKind::ExpressionP19 => "Expression: Identifier",
        };
        write!(f, "{}", name)
    }
}
#[allow(clippy::upper_case_acronyms)]
#[allow(dead_code)]
#[derive(Clone, Copy, Debug)]
pub enum NonTermKind {
    EMPTY,
    AUG,
    Program,
    StatementList,
    Statement1,
    Statement,
    Assignment,
    IfStatement,
    ElseClauseOpt,
    ElseClause,
    VariableDeclaration,
    ConstantDeclaration,
    WhileStatement,
    ForStatement,
    Expression,
}
impl From<ProdKind> for NonTermKind {
    fn from(prod: ProdKind) -> Self {
        match prod {
            ProdKind::ProgramP1 => NonTermKind::Program,
            ProdKind::StatementListP1 => NonTermKind::StatementList,
            ProdKind::Statement1P1 => NonTermKind::Statement1,
            ProdKind::Statement1P2 => NonTermKind::Statement1,
            ProdKind::StatementP1 => NonTermKind::Statement,
            ProdKind::StatementP2 => NonTermKind::Statement,
            ProdKind::StatementP3 => NonTermKind::Statement,
            ProdKind::StatementP4 => NonTermKind::Statement,
            ProdKind::StatementP5 => NonTermKind::Statement,
            ProdKind::StatementP6 => NonTermKind::Statement,
            ProdKind::AssignmentAssignment => NonTermKind::Assignment,
            ProdKind::IfStatementIfStatement => NonTermKind::IfStatement,
            ProdKind::ElseClauseOptP1 => NonTermKind::ElseClauseOpt,
            ProdKind::ElseClauseOptP2 => NonTermKind::ElseClauseOpt,
            ProdKind::ElseClauseElseStatement => NonTermKind::ElseClause,
            ProdKind::VariableDeclarationVariableDeclaration => {
                NonTermKind::VariableDeclaration
            }
            ProdKind::ConstantDeclarationConstantDeclaration => {
                NonTermKind::ConstantDeclaration
            }
            ProdKind::WhileStatementWhile => NonTermKind::WhileStatement,
            ProdKind::ForStatementFor => NonTermKind::ForStatement,
            ProdKind::ExpressionAdd => NonTermKind::Expression,
            ProdKind::ExpressionSub => NonTermKind::Expression,
            ProdKind::ExpressionMul => NonTermKind::Expression,
            ProdKind::ExpressionDiv => NonTermKind::Expression,
            ProdKind::ExpressionEquals => NonTermKind::Expression,
            ProdKind::ExpressionNotEquals => NonTermKind::Expression,
            ProdKind::ExpressionLess => NonTermKind::Expression,
            ProdKind::ExpressionLessOrEquals => NonTermKind::Expression,
            ProdKind::ExpressionGreater => NonTermKind::Expression,
            ProdKind::ExpressionGreaterOrEquals => NonTermKind::Expression,
            ProdKind::ExpressionAnd => NonTermKind::Expression,
            ProdKind::ExpressionOr => NonTermKind::Expression,
            ProdKind::ExpressionUnaryMinus => NonTermKind::Expression,
            ProdKind::ExpressionUnaryNegation => NonTermKind::Expression,
            ProdKind::ExpressionP15 => NonTermKind::Expression,
            ProdKind::ExpressionP16 => NonTermKind::Expression,
            ProdKind::ExpressionP17 => NonTermKind::Expression,
            ProdKind::ExpressionP18 => NonTermKind::Expression,
            ProdKind::ExpressionP19 => NonTermKind::Expression,
        }
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    #[default]
    AUGS0,
    OpenBraceS1,
    ProgramS2,
    StatementListS3,
    IdentifierS4,
    IfS5,
    LetS6,
    ConstS7,
    WhileS8,
    ForS9,
    Statement1S10,
    StatementS11,
    AssignmentS12,
    IfStatementS13,
    VariableDeclarationS14,
    ConstantDeclarationS15,
    WhileStatementS16,
    ForStatementS17,
    EqualsS18,
    OpenParenthesisS19,
    IdentifierS20,
    IdentifierS21,
    OpenParenthesisS22,
    OpenParenthesisS23,
    CloseBraceS24,
    StatementS25,
    NumberS26,
    MinusS27,
    TrueS28,
    FalseS29,
    OpenParenthesisS30,
    BangS31,
    IdentifierS32,
    ExpressionS33,
    ExpressionS34,
    EqualsS35,
    EqualsS36,
    ExpressionS37,
    IdentifierS38,
    ExpressionS39,
    ExpressionS40,
    ExpressionS41,
    PlusS42,
    MinusS43,
    MulS44,
    DivS45,
    EqualsEqualsS46,
    BangEqualsS47,
    LessS48,
    LessOrEqualsS49,
    GreaterS50,
    GreaterOrEqualsS51,
    AmpersandAmpersandS52,
    PipePipeS53,
    SemiColonS54,
    CloseParenthesisS55,
    ExpressionS56,
    ExpressionS57,
    CloseParenthesisS58,
    EqualsS59,
    CloseParenthesisS60,
    ExpressionS61,
    ExpressionS62,
    ExpressionS63,
    ExpressionS64,
    ExpressionS65,
    ExpressionS66,
    ExpressionS67,
    ExpressionS68,
    ExpressionS69,
    ExpressionS70,
    ExpressionS71,
    ExpressionS72,
    StatementListS73,
    SemiColonS74,
    SemiColonS75,
    StatementListS76,
    ExpressionS77,
    ElseS78,
    ElseClauseOptS79,
    ElseClauseS80,
    ToS81,
    StatementListS82,
    ExpressionS83,
    CloseParenthesisS84,
    StatementListS85,
}
impl StateT for State {
    fn default_layout() -> Option<Self> {
        None
    }
}
impl From<State> for usize {
    fn from(s: State) -> Self {
        s as usize
    }
}
impl std::fmt::Debug for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            State::AUGS0 => "0:AUG",
            State::OpenBraceS1 => "1:OpenBrace",
            State::ProgramS2 => "2:Program",
            State::StatementListS3 => "3:StatementList",
            State::IdentifierS4 => "4:Identifier",
            State::IfS5 => "5:If",
            State::LetS6 => "6:Let",
            State::ConstS7 => "7:Const",
            State::WhileS8 => "8:While",
            State::ForS9 => "9:For",
            State::Statement1S10 => "10:Statement1",
            State::StatementS11 => "11:Statement",
            State::AssignmentS12 => "12:Assignment",
            State::IfStatementS13 => "13:IfStatement",
            State::VariableDeclarationS14 => "14:VariableDeclaration",
            State::ConstantDeclarationS15 => "15:ConstantDeclaration",
            State::WhileStatementS16 => "16:WhileStatement",
            State::ForStatementS17 => "17:ForStatement",
            State::EqualsS18 => "18:Equals",
            State::OpenParenthesisS19 => "19:OpenParenthesis",
            State::IdentifierS20 => "20:Identifier",
            State::IdentifierS21 => "21:Identifier",
            State::OpenParenthesisS22 => "22:OpenParenthesis",
            State::OpenParenthesisS23 => "23:OpenParenthesis",
            State::CloseBraceS24 => "24:CloseBrace",
            State::StatementS25 => "25:Statement",
            State::NumberS26 => "26:Number",
            State::MinusS27 => "27:Minus",
            State::TrueS28 => "28:True",
            State::FalseS29 => "29:False",
            State::OpenParenthesisS30 => "30:OpenParenthesis",
            State::BangS31 => "31:Bang",
            State::IdentifierS32 => "32:Identifier",
            State::ExpressionS33 => "33:Expression",
            State::ExpressionS34 => "34:Expression",
            State::EqualsS35 => "35:Equals",
            State::EqualsS36 => "36:Equals",
            State::ExpressionS37 => "37:Expression",
            State::IdentifierS38 => "38:Identifier",
            State::ExpressionS39 => "39:Expression",
            State::ExpressionS40 => "40:Expression",
            State::ExpressionS41 => "41:Expression",
            State::PlusS42 => "42:Plus",
            State::MinusS43 => "43:Minus",
            State::MulS44 => "44:Mul",
            State::DivS45 => "45:Div",
            State::EqualsEqualsS46 => "46:EqualsEquals",
            State::BangEqualsS47 => "47:BangEquals",
            State::LessS48 => "48:Less",
            State::LessOrEqualsS49 => "49:LessOrEquals",
            State::GreaterS50 => "50:Greater",
            State::GreaterOrEqualsS51 => "51:GreaterOrEquals",
            State::AmpersandAmpersandS52 => "52:AmpersandAmpersand",
            State::PipePipeS53 => "53:PipePipe",
            State::SemiColonS54 => "54:SemiColon",
            State::CloseParenthesisS55 => "55:CloseParenthesis",
            State::ExpressionS56 => "56:Expression",
            State::ExpressionS57 => "57:Expression",
            State::CloseParenthesisS58 => "58:CloseParenthesis",
            State::EqualsS59 => "59:Equals",
            State::CloseParenthesisS60 => "60:CloseParenthesis",
            State::ExpressionS61 => "61:Expression",
            State::ExpressionS62 => "62:Expression",
            State::ExpressionS63 => "63:Expression",
            State::ExpressionS64 => "64:Expression",
            State::ExpressionS65 => "65:Expression",
            State::ExpressionS66 => "66:Expression",
            State::ExpressionS67 => "67:Expression",
            State::ExpressionS68 => "68:Expression",
            State::ExpressionS69 => "69:Expression",
            State::ExpressionS70 => "70:Expression",
            State::ExpressionS71 => "71:Expression",
            State::ExpressionS72 => "72:Expression",
            State::StatementListS73 => "73:StatementList",
            State::SemiColonS74 => "74:SemiColon",
            State::SemiColonS75 => "75:SemiColon",
            State::StatementListS76 => "76:StatementList",
            State::ExpressionS77 => "77:Expression",
            State::ElseS78 => "78:Else",
            State::ElseClauseOptS79 => "79:ElseClauseOpt",
            State::ElseClauseS80 => "80:ElseClause",
            State::ToS81 => "81:To",
            State::StatementListS82 => "82:StatementList",
            State::ExpressionS83 => "83:Expression",
            State::CloseParenthesisS84 => "84:CloseParenthesis",
            State::StatementListS85 => "85:StatementList",
        };
        write!(f, "{name}")
    }
}
#[derive(Debug)]
pub enum Symbol {
    Terminal(Terminal),
    NonTerminal(NonTerminal),
}
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug)]
pub enum Terminal {
    Number(compiler_actions::Number),
    Plus,
    Minus,
    Mul,
    Div,
    True,
    False,
    OpenParenthesis,
    CloseParenthesis,
    Bang,
    EqualsEquals,
    BangEquals,
    Less,
    LessOrEquals,
    Greater,
    GreaterOrEquals,
    AmpersandAmpersand,
    PipePipe,
    Identifier(compiler_actions::Identifier),
    OpenBrace,
    CloseBrace,
    Equals,
    SemiColon,
    If,
    Else,
    Let,
    Const,
    While,
    For,
    To,
}
#[derive(Debug)]
pub enum NonTerminal {
    Program(compiler_actions::Program),
    StatementList(compiler_actions::StatementList),
    Statement1(compiler_actions::Statement1),
    Statement(compiler_actions::Statement),
    Assignment(compiler_actions::Assignment),
    IfStatement(compiler_actions::IfStatement),
    ElseClauseOpt(compiler_actions::ElseClauseOpt),
    ElseClause(compiler_actions::ElseClause),
    VariableDeclaration(compiler_actions::VariableDeclaration),
    ConstantDeclaration(compiler_actions::ConstantDeclaration),
    WhileStatement(compiler_actions::WhileStatement),
    ForStatement(compiler_actions::ForStatement),
    Expression(compiler_actions::Expression),
}
type ActionFn = fn(token: TokenKind) -> Vec<Action<State, ProdKind>>;
pub struct CompilerParserDefinition {
    actions: [ActionFn; STATE_COUNT],
    gotos: [fn(nonterm: NonTermKind) -> State; STATE_COUNT],
    token_kinds: [[Option<(TokenKind, bool)>; MAX_RECOGNIZERS]; STATE_COUNT],
}
fn action_aug_s0(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_openbrace_s1(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS4)]),
        TK::If => Vec::from(&[Shift(State::IfS5)]),
        TK::Let => Vec::from(&[Shift(State::LetS6)]),
        TK::Const => Vec::from(&[Shift(State::ConstS7)]),
        TK::While => Vec::from(&[Shift(State::WhileS8)]),
        TK::For => Vec::from(&[Shift(State::ForS9)]),
        _ => vec![],
    }
}
fn action_program_s2(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_statementlist_s3(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ProgramP1, 1usize)]),
        _ => vec![],
    }
}
fn action_identifier_s4(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS18)]),
        _ => vec![],
    }
}
fn action_if_s5(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS19)]),
        _ => vec![],
    }
}
fn action_let_s6(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS20)]),
        _ => vec![],
    }
}
fn action_const_s7(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS21)]),
        _ => vec![],
    }
}
fn action_while_s8(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS22)]),
        _ => vec![],
    }
}
fn action_for_s9(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS23)]),
        _ => vec![],
    }
}
fn action_statement1_s10(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS4)]),
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS24)]),
        TK::If => Vec::from(&[Shift(State::IfS5)]),
        TK::Let => Vec::from(&[Shift(State::LetS6)]),
        TK::Const => Vec::from(&[Shift(State::ConstS7)]),
        TK::While => Vec::from(&[Shift(State::WhileS8)]),
        TK::For => Vec::from(&[Shift(State::ForS9)]),
        _ => vec![],
    }
}
fn action_statement_s11(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::Statement1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_assignment_s12(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP1, 1usize)]),
        _ => vec![],
    }
}
fn action_ifstatement_s13(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP2, 1usize)]),
        _ => vec![],
    }
}
fn action_variabledeclaration_s14(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP3, 1usize)]),
        _ => vec![],
    }
}
fn action_constantdeclaration_s15(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP4, 1usize)]),
        _ => vec![],
    }
}
fn action_whilestatement_s16(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP5, 1usize)]),
        _ => vec![],
    }
}
fn action_forstatement_s17(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementP6, 1usize)]),
        _ => vec![],
    }
}
fn action_equals_s18(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s19(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_identifier_s20(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS35)]),
        _ => vec![],
    }
}
fn action_identifier_s21(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS36)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s22(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s23(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS38)]),
        _ => vec![],
    }
}
fn action_closebrace_s24(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Identifier => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::If => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Else => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Let => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::Const => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::While => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        TK::For => Vec::from(&[Reduce(PK::StatementListP1, 3usize)]),
        _ => vec![],
    }
}
fn action_statement_s25(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::If => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::Let => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::Const => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::While => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        TK::For => Vec::from(&[Reduce(PK::Statement1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_number_s26(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP16, 1usize)]),
        _ => vec![],
    }
}
fn action_minus_s27(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_true_s28(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP17, 1usize)]),
        _ => vec![],
    }
}
fn action_false_s29(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP18, 1usize)]),
        _ => vec![],
    }
}
fn action_openparenthesis_s30(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_bang_s31(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_identifier_s32(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP19, 1usize)]),
        _ => vec![],
    }
}
fn action_expression_s33(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS54)]),
        _ => vec![],
    }
}
fn action_expression_s34(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS55)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        _ => vec![],
    }
}
fn action_equals_s35(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_equals_s36(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_expression_s37(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS58)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        _ => vec![],
    }
}
fn action_identifier_s38(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Equals => Vec::from(&[Shift(State::EqualsS59)]),
        _ => vec![],
    }
}
fn action_expression_s39(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionUnaryMinus, 2usize)]),
        _ => vec![],
    }
}
fn action_expression_s40(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS60)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        _ => vec![],
    }
}
fn action_expression_s41(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionUnaryNegation, 2usize)]),
        _ => vec![],
    }
}
fn action_plus_s42(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_minus_s43(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_mul_s44(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_div_s45(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_equalsequals_s46(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_bangequals_s47(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_less_s48(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_lessorequals_s49(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_greater_s50(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_greaterorequals_s51(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_ampersandampersand_s52(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_pipepipe_s53(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_semicolon_s54(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::If => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::Let => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::Const => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::While => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        TK::For => Vec::from(&[Reduce(PK::AssignmentAssignment, 4usize)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s55(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_expression_s56(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS74)]),
        _ => vec![],
    }
}
fn action_expression_s57(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS75)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s58(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_equals_s59(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s60(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionP15, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s61(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionAdd, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s62(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionSub, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s63(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionMul, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s64(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Minus => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Mul => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Div => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionDiv, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s65(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s66(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionNotEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s67(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionLess, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s68(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionLessOrEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s69(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::GreaterOrEquals => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionGreater, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s70(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::EqualsEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::BangEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::Less => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::LessOrEquals => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::Greater => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::GreaterOrEquals => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::AmpersandAmpersand => {
            Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)])
        }
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionGreaterOrEquals, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s71(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionAnd, 3usize)]),
        _ => vec![],
    }
}
fn action_expression_s72(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::PipePipe => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::SemiColon => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        TK::To => Vec::from(&[Reduce(PK::ExpressionOr, 3usize)]),
        _ => vec![],
    }
}
fn action_statementlist_s73(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::Else => Vec::from(&[Shift(State::ElseS78)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s74(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::CloseBrace => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::If => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::Let => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::Const => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::While => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        TK::For => {
            Vec::from(&[Reduce(PK::VariableDeclarationVariableDeclaration, 5usize)])
        }
        _ => vec![],
    }
}
fn action_semicolon_s75(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::CloseBrace => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::If => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::Let => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::Const => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::While => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        TK::For => {
            Vec::from(&[Reduce(PK::ConstantDeclarationConstantDeclaration, 5usize)])
        }
        _ => vec![],
    }
}
fn action_statementlist_s76(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::If => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::Let => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::Const => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::While => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        TK::For => Vec::from(&[Reduce(PK::WhileStatementWhile, 5usize)]),
        _ => vec![],
    }
}
fn action_expression_s77(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        TK::To => Vec::from(&[Shift(State::ToS81)]),
        _ => vec![],
    }
}
fn action_else_s78(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_elseclauseopt_s79(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::If => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::Let => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::Const => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::While => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        TK::For => Vec::from(&[Reduce(PK::IfStatementIfStatement, 6usize)]),
        _ => vec![],
    }
}
fn action_elseclause_s80(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_to_s81(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Number => Vec::from(&[Shift(State::NumberS26)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS27)]),
        TK::True => Vec::from(&[Shift(State::TrueS28)]),
        TK::False => Vec::from(&[Shift(State::FalseS29)]),
        TK::OpenParenthesis => Vec::from(&[Shift(State::OpenParenthesisS30)]),
        TK::Bang => Vec::from(&[Shift(State::BangS31)]),
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS32)]),
        _ => vec![],
    }
}
fn action_statementlist_s82(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::If => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::While => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        TK::For => Vec::from(&[Reduce(PK::ElseClauseElseStatement, 2usize)]),
        _ => vec![],
    }
}
fn action_expression_s83(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Plus => Vec::from(&[Shift(State::PlusS42)]),
        TK::Minus => Vec::from(&[Shift(State::MinusS43)]),
        TK::Mul => Vec::from(&[Shift(State::MulS44)]),
        TK::Div => Vec::from(&[Shift(State::DivS45)]),
        TK::CloseParenthesis => Vec::from(&[Shift(State::CloseParenthesisS84)]),
        TK::EqualsEquals => Vec::from(&[Shift(State::EqualsEqualsS46)]),
        TK::BangEquals => Vec::from(&[Shift(State::BangEqualsS47)]),
        TK::Less => Vec::from(&[Shift(State::LessS48)]),
        TK::LessOrEquals => Vec::from(&[Shift(State::LessOrEqualsS49)]),
        TK::Greater => Vec::from(&[Shift(State::GreaterS50)]),
        TK::GreaterOrEquals => Vec::from(&[Shift(State::GreaterOrEqualsS51)]),
        TK::AmpersandAmpersand => Vec::from(&[Shift(State::AmpersandAmpersandS52)]),
        TK::PipePipe => Vec::from(&[Shift(State::PipePipeS53)]),
        _ => vec![],
    }
}
fn action_closeparenthesis_s84(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS1)]),
        _ => vec![],
    }
}
fn action_statementlist_s85(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::If => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::Let => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::Const => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::While => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        TK::For => Vec::from(&[Reduce(PK::ForStatementFor, 9usize)]),
        _ => vec![],
    }
}
fn goto_aug_s0(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Program => State::ProgramS2,
        NonTermKind::StatementList => State::StatementListS3,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGS0
            )
        }
    }
}
fn goto_openbrace_s1(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Statement1 => State::Statement1S10,
        NonTermKind::Statement => State::StatementS11,
        NonTermKind::Assignment => State::AssignmentS12,
        NonTermKind::IfStatement => State::IfStatementS13,
        NonTermKind::VariableDeclaration => State::VariableDeclarationS14,
        NonTermKind::ConstantDeclaration => State::ConstantDeclarationS15,
        NonTermKind::WhileStatement => State::WhileStatementS16,
        NonTermKind::ForStatement => State::ForStatementS17,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS1
            )
        }
    }
}
fn goto_statement1_s10(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Statement => State::StatementS25,
        NonTermKind::Assignment => State::AssignmentS12,
        NonTermKind::IfStatement => State::IfStatementS13,
        NonTermKind::VariableDeclaration => State::VariableDeclarationS14,
        NonTermKind::ConstantDeclaration => State::ConstantDeclarationS15,
        NonTermKind::WhileStatement => State::WhileStatementS16,
        NonTermKind::ForStatement => State::ForStatementS17,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Statement1S10
            )
        }
    }
}
fn goto_equals_s18(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS33,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS18
            )
        }
    }
}
fn goto_openparenthesis_s19(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS34,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS19
            )
        }
    }
}
fn goto_openparenthesis_s22(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS37,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS22
            )
        }
    }
}
fn goto_minus_s27(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS39,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MinusS27
            )
        }
    }
}
fn goto_openparenthesis_s30(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenParenthesisS30
            )
        }
    }
}
fn goto_bang_s31(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS41,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::BangS31
            )
        }
    }
}
fn goto_equals_s35(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS56,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS35
            )
        }
    }
}
fn goto_equals_s36(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS57,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS36
            )
        }
    }
}
fn goto_plus_s42(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS61,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PlusS42
            )
        }
    }
}
fn goto_minus_s43(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS62,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MinusS43
            )
        }
    }
}
fn goto_mul_s44(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS63,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::MulS44
            )
        }
    }
}
fn goto_div_s45(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS64,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::DivS45
            )
        }
    }
}
fn goto_equalsequals_s46(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS65,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsEqualsS46
            )
        }
    }
}
fn goto_bangequals_s47(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS66,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::BangEqualsS47
            )
        }
    }
}
fn goto_less_s48(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS67,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::LessS48
            )
        }
    }
}
fn goto_lessorequals_s49(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS68,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::LessOrEqualsS49
            )
        }
    }
}
fn goto_greater_s50(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS69,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GreaterS50
            )
        }
    }
}
fn goto_greaterorequals_s51(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS70,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GreaterOrEqualsS51
            )
        }
    }
}
fn goto_ampersandampersand_s52(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS71,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AmpersandAmpersandS52
            )
        }
    }
}
fn goto_pipepipe_s53(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS72,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PipePipeS53
            )
        }
    }
}
fn goto_closeparenthesis_s55(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS73,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS55
            )
        }
    }
}
fn goto_closeparenthesis_s58(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS76,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS58
            )
        }
    }
}
fn goto_equals_s59(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS77,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS59
            )
        }
    }
}
fn goto_statementlist_s73(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ElseClauseOpt => State::ElseClauseOptS79,
        NonTermKind::ElseClause => State::ElseClauseS80,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::StatementListS73
            )
        }
    }
}
fn goto_else_s78(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS82,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ElseS78
            )
        }
    }
}
fn goto_to_s81(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS83,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ToS81
            )
        }
    }
}
fn goto_closeparenthesis_s84(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::StatementList => State::StatementListS85,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CloseParenthesisS84
            )
        }
    }
}
fn goto_invalid(_nonterm_kind: NonTermKind) -> State {
    panic!("Invalid GOTO entry!");
}
pub(crate) static PARSER_DEFINITION: CompilerParserDefinition = CompilerParserDefinition {
    actions: [
        action_aug_s0,
        action_openbrace_s1,
        action_program_s2,
        action_statementlist_s3,
        action_identifier_s4,
        action_if_s5,
        action_let_s6,
        action_const_s7,
        action_while_s8,
        action_for_s9,
        action_statement1_s10,
        action_statement_s11,
        action_assignment_s12,
        action_ifstatement_s13,
        action_variabledeclaration_s14,
        action_constantdeclaration_s15,
        action_whilestatement_s16,
        action_forstatement_s17,
        action_equals_s18,
        action_openparenthesis_s19,
        action_identifier_s20,
        action_identifier_s21,
        action_openparenthesis_s22,
        action_openparenthesis_s23,
        action_closebrace_s24,
        action_statement_s25,
        action_number_s26,
        action_minus_s27,
        action_true_s28,
        action_false_s29,
        action_openparenthesis_s30,
        action_bang_s31,
        action_identifier_s32,
        action_expression_s33,
        action_expression_s34,
        action_equals_s35,
        action_equals_s36,
        action_expression_s37,
        action_identifier_s38,
        action_expression_s39,
        action_expression_s40,
        action_expression_s41,
        action_plus_s42,
        action_minus_s43,
        action_mul_s44,
        action_div_s45,
        action_equalsequals_s46,
        action_bangequals_s47,
        action_less_s48,
        action_lessorequals_s49,
        action_greater_s50,
        action_greaterorequals_s51,
        action_ampersandampersand_s52,
        action_pipepipe_s53,
        action_semicolon_s54,
        action_closeparenthesis_s55,
        action_expression_s56,
        action_expression_s57,
        action_closeparenthesis_s58,
        action_equals_s59,
        action_closeparenthesis_s60,
        action_expression_s61,
        action_expression_s62,
        action_expression_s63,
        action_expression_s64,
        action_expression_s65,
        action_expression_s66,
        action_expression_s67,
        action_expression_s68,
        action_expression_s69,
        action_expression_s70,
        action_expression_s71,
        action_expression_s72,
        action_statementlist_s73,
        action_semicolon_s74,
        action_semicolon_s75,
        action_statementlist_s76,
        action_expression_s77,
        action_else_s78,
        action_elseclauseopt_s79,
        action_elseclause_s80,
        action_to_s81,
        action_statementlist_s82,
        action_expression_s83,
        action_closeparenthesis_s84,
        action_statementlist_s85,
    ],
    gotos: [
        goto_aug_s0,
        goto_openbrace_s1,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_statement1_s10,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_equals_s18,
        goto_openparenthesis_s19,
        goto_invalid,
        goto_invalid,
        goto_openparenthesis_s22,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_minus_s27,
        goto_invalid,
        goto_invalid,
        goto_openparenthesis_s30,
        goto_bang_s31,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_equals_s35,
        goto_equals_s36,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_plus_s42,
        goto_minus_s43,
        goto_mul_s44,
        goto_div_s45,
        goto_equalsequals_s46,
        goto_bangequals_s47,
        goto_less_s48,
        goto_lessorequals_s49,
        goto_greater_s50,
        goto_greaterorequals_s51,
        goto_ampersandampersand_s52,
        goto_pipepipe_s53,
        goto_invalid,
        goto_closeparenthesis_s55,
        goto_invalid,
        goto_invalid,
        goto_closeparenthesis_s58,
        goto_equals_s59,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_statementlist_s73,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_else_s78,
        goto_invalid,
        goto_invalid,
        goto_to_s81,
        goto_invalid,
        goto_invalid,
        goto_closeparenthesis_s84,
        goto_invalid,
    ],
    token_kinds: [
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenParenthesis, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Else, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::Equals, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            Some((TK::SemiColon, true)),
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Else, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::To, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::False, true)),
            Some((TK::True, true)),
            Some((TK::Minus, true)),
            Some((TK::OpenParenthesis, true)),
            Some((TK::Bang, true)),
            Some((TK::Number, false)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::EqualsEquals, true)),
            Some((TK::BangEquals, true)),
            Some((TK::LessOrEquals, true)),
            Some((TK::GreaterOrEquals, true)),
            Some((TK::AmpersandAmpersand, true)),
            Some((TK::PipePipe, true)),
            Some((TK::Plus, true)),
            Some((TK::Minus, true)),
            Some((TK::Mul, true)),
            Some((TK::Div, true)),
            Some((TK::CloseParenthesis, true)),
            Some((TK::Less, true)),
            Some((TK::Greater, true)),
            None,
            None,
        ],
        [
            Some((TK::OpenBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Const, true)),
            Some((TK::While, true)),
            Some((TK::Let, true)),
            Some((TK::For, true)),
            Some((TK::If, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Identifier, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
    ],
};
impl ParserDefinition<State, ProdKind, TokenKind, NonTermKind>
for CompilerParserDefinition {
    fn actions(&self, state: State, token: TokenKind) -> Vec<Action<State, ProdKind>> {
        PARSER_DEFINITION.actions[state as usize](token)
    }
    fn goto(&self, state: State, nonterm: NonTermKind) -> State {
        PARSER_DEFINITION.gotos[state as usize](nonterm)
    }
    fn expected_token_kinds(&self, state: State) -> Vec<(TokenKind, bool)> {
        PARSER_DEFINITION.token_kinds[state as usize].iter().map_while(|t| *t).collect()
    }
    fn longest_match() -> bool {
        true
    }
    fn grammar_order() -> bool {
        true
    }
}
pub(crate) type Context<'i, I> = LRContext<'i, I, State, TokenKind>;
pub struct CompilerParser<
    'i,
    I: InputT + ?Sized,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B,
>(
    LRParser<
        'i,
        Context<'i, I>,
        State,
        ProdKind,
        TokenKind,
        NonTermKind,
        CompilerParserDefinition,
        L,
        B,
        I,
    >,
);
#[allow(dead_code)]
impl<
    'i,
> CompilerParser<
    'i,
    Input,
    StringLexer<Context<'i, Input>, State, TokenKind, TokenRecognizer, TERMINAL_COUNT>,
    DefaultBuilder,
> {
    pub fn new() -> Self {
        Self(
            LRParser::new(
                &PARSER_DEFINITION,
                State::default(),
                false,
                false,
                StringLexer::new(true, &RECOGNIZERS),
                DefaultBuilder::new(),
            ),
        )
    }
}
#[allow(dead_code)]
impl<'i, I, L, B> Parser<'i, I, Context<'i, I>, State, TokenKind>
for CompilerParser<'i, I, L, B>
where
    I: InputT + ?Sized + Debug,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B: LRBuilder<'i, I, Context<'i, I>, State, ProdKind, TokenKind>,
{
    type Output = B::Output;
    fn parse(&self, input: &'i I) -> Result<Self::Output> {
        self.0.parse(input)
    }
    fn parse_with_context(
        &self,
        context: &mut Context<'i, I>,
        input: &'i I,
    ) -> Result<Self::Output> {
        self.0.parse_with_context(context, input)
    }
    fn parse_file<'a, F: AsRef<std::path::Path>>(
        &'a mut self,
        file: F,
    ) -> Result<Self::Output>
    where
        'a: 'i,
    {
        self.0.parse_file(file)
    }
}
#[allow(dead_code)]
#[derive(Debug)]
pub enum Recognizer {
    Stop,
    StrMatch(&'static str),
    RegexMatch(Lazy<Regex>),
}
#[allow(dead_code)]
#[derive(Debug)]
pub struct TokenRecognizer(TokenKind, Recognizer);
impl<'i> TokenRecognizerT<'i> for TokenRecognizer {
    fn recognize(&self, input: &'i str) -> Option<&'i str> {
        match &self {
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::StrMatch(s)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                if input.starts_with(s) {
                    log!("{}", "recognized".bold().green());
                    Some(s)
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::RegexMatch(r)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                let match_str = r.find(input);
                match match_str {
                    Some(x) => {
                        let x_str = x.as_str();
                        log!("{} '{}'", "recognized".bold().green(), x_str);
                        Some(x_str)
                    }
                    _ => {
                        log!("{}", "not recognized".red());
                        None
                    }
                }
            }
            TokenRecognizer(_, Recognizer::Stop) => {
                logn!("{} STOP -- ", "    Recognizing".green());
                if input.is_empty() {
                    log!("{}", "recognized".bold().green());
                    Some("")
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
        }
    }
}
pub(crate) static RECOGNIZERS: [TokenRecognizer; TERMINAL_COUNT] = [
    TokenRecognizer(TokenKind::STOP, Recognizer::Stop),
    TokenRecognizer(
        TokenKind::Number,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "\\d+(\\.\\d+)?")).unwrap() }),
        ),
    ),
    TokenRecognizer(TokenKind::Plus, Recognizer::StrMatch("+")),
    TokenRecognizer(TokenKind::Minus, Recognizer::StrMatch("-")),
    TokenRecognizer(TokenKind::Mul, Recognizer::StrMatch("*")),
    TokenRecognizer(TokenKind::Div, Recognizer::StrMatch("/")),
    TokenRecognizer(TokenKind::True, Recognizer::StrMatch("true")),
    TokenRecognizer(TokenKind::False, Recognizer::StrMatch("false")),
    TokenRecognizer(TokenKind::OpenParenthesis, Recognizer::StrMatch("(")),
    TokenRecognizer(TokenKind::CloseParenthesis, Recognizer::StrMatch(")")),
    TokenRecognizer(TokenKind::Bang, Recognizer::StrMatch("!")),
    TokenRecognizer(TokenKind::EqualsEquals, Recognizer::StrMatch("==")),
    TokenRecognizer(TokenKind::BangEquals, Recognizer::StrMatch("!=")),
    TokenRecognizer(TokenKind::Less, Recognizer::StrMatch("<")),
    TokenRecognizer(TokenKind::LessOrEquals, Recognizer::StrMatch("<=")),
    TokenRecognizer(TokenKind::Greater, Recognizer::StrMatch(">")),
    TokenRecognizer(TokenKind::GreaterOrEquals, Recognizer::StrMatch(">=")),
    TokenRecognizer(TokenKind::AmpersandAmpersand, Recognizer::StrMatch("&&")),
    TokenRecognizer(TokenKind::PipePipe, Recognizer::StrMatch("||")),
    TokenRecognizer(
        TokenKind::Identifier,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z_]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(TokenKind::OpenBrace, Recognizer::StrMatch("{")),
    TokenRecognizer(TokenKind::CloseBrace, Recognizer::StrMatch("}")),
    TokenRecognizer(TokenKind::Equals, Recognizer::StrMatch("=")),
    TokenRecognizer(TokenKind::SemiColon, Recognizer::StrMatch(";")),
    TokenRecognizer(TokenKind::If, Recognizer::StrMatch("if")),
    TokenRecognizer(TokenKind::Else, Recognizer::StrMatch("else")),
    TokenRecognizer(TokenKind::Let, Recognizer::StrMatch("let")),
    TokenRecognizer(TokenKind::Const, Recognizer::StrMatch("const")),
    TokenRecognizer(TokenKind::While, Recognizer::StrMatch("while")),
    TokenRecognizer(TokenKind::For, Recognizer::StrMatch("for")),
    TokenRecognizer(TokenKind::To, Recognizer::StrMatch("to")),
];
pub struct DefaultBuilder {
    res_stack: Vec<Symbol>,
}
impl DefaultBuilder {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self { res_stack: vec![] }
    }
}
impl Builder for DefaultBuilder {
    type Output = compiler_actions::Program;
    fn get_result(&mut self) -> Self::Output {
        match self.res_stack.pop().unwrap() {
            Symbol::NonTerminal(NonTerminal::Program(r)) => r,
            _ => panic!("Invalid result on the parse stack!"),
        }
    }
}
impl<'i> LRBuilder<'i, Input, Context<'i, Input>, State, ProdKind, TokenKind>
for DefaultBuilder {
    #![allow(unused_variables)]
    fn shift_action(
        &mut self,
        context: &mut Context<'i, Input>,
        token: Token<'i, Input, TokenKind>,
    ) {
        let val = match token.kind {
            TokenKind::STOP => panic!("Cannot shift STOP token!"),
            TokenKind::Number => {
                Terminal::Number(compiler_actions::number(&*context, token))
            }
            TokenKind::Plus => Terminal::Plus,
            TokenKind::Minus => Terminal::Minus,
            TokenKind::Mul => Terminal::Mul,
            TokenKind::Div => Terminal::Div,
            TokenKind::True => Terminal::True,
            TokenKind::False => Terminal::False,
            TokenKind::OpenParenthesis => Terminal::OpenParenthesis,
            TokenKind::CloseParenthesis => Terminal::CloseParenthesis,
            TokenKind::Bang => Terminal::Bang,
            TokenKind::EqualsEquals => Terminal::EqualsEquals,
            TokenKind::BangEquals => Terminal::BangEquals,
            TokenKind::Less => Terminal::Less,
            TokenKind::LessOrEquals => Terminal::LessOrEquals,
            TokenKind::Greater => Terminal::Greater,
            TokenKind::GreaterOrEquals => Terminal::GreaterOrEquals,
            TokenKind::AmpersandAmpersand => Terminal::AmpersandAmpersand,
            TokenKind::PipePipe => Terminal::PipePipe,
            TokenKind::Identifier => {
                Terminal::Identifier(compiler_actions::identifier(&*context, token))
            }
            TokenKind::OpenBrace => Terminal::OpenBrace,
            TokenKind::CloseBrace => Terminal::CloseBrace,
            TokenKind::Equals => Terminal::Equals,
            TokenKind::SemiColon => Terminal::SemiColon,
            TokenKind::If => Terminal::If,
            TokenKind::Else => Terminal::Else,
            TokenKind::Let => Terminal::Let,
            TokenKind::Const => Terminal::Const,
            TokenKind::While => Terminal::While,
            TokenKind::For => Terminal::For,
            TokenKind::To => Terminal::To,
        };
        self.res_stack.push(Symbol::Terminal(val));
    }
    fn reduce_action(
        &mut self,
        context: &mut Context<'i, Input>,
        prod: ProdKind,
        _prod_len: usize,
    ) {
        let prod = match prod {
            ProdKind::ProgramP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::StatementList(p0)) => {
                        NonTerminal::Program(
                            compiler_actions::program_statement_list(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementListP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::Statement1(p0)), _) => {
                        NonTerminal::StatementList(
                            compiler_actions::statement_list_statement1(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Statement1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Statement1(p0)),
                        Symbol::NonTerminal(NonTerminal::Statement(p1)),
                    ) => {
                        NonTerminal::Statement1(
                            compiler_actions::statement1_c1(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Statement1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Statement(p0)) => {
                        NonTerminal::Statement1(
                            compiler_actions::statement1_statement(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Assignment(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_assignment(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::IfStatement(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_if_statement(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::VariableDeclaration(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_variable_declaration(
                                &*context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP4 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ConstantDeclaration(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_constant_declaration(
                                &*context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP5 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::WhileStatement(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_while_statement(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::StatementP6 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ForStatement(p0)) => {
                        NonTerminal::Statement(
                            compiler_actions::statement_for_statement(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AssignmentAssignment => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                        _,
                    ) => {
                        NonTerminal::Assignment(
                            compiler_actions::assignment_assignment(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IfStatementIfStatement => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 6usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::StatementList(p1)),
                        Symbol::NonTerminal(NonTerminal::ElseClauseOpt(p2)),
                    ) => {
                        NonTerminal::IfStatement(
                            compiler_actions::if_statement_if_statement(
                                &*context,
                                p0,
                                p1,
                                p2,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ElseClauseOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ElseClause(p0)) => {
                        NonTerminal::ElseClauseOpt(
                            compiler_actions::else_clause_opt_else_clause(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ElseClauseOptP2 => {
                NonTerminal::ElseClauseOpt(
                    compiler_actions::else_clause_opt_empty(context),
                )
            }
            ProdKind::ElseClauseElseStatement => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::StatementList(p0))) => {
                        NonTerminal::ElseClause(
                            compiler_actions::else_clause_else_statement(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::VariableDeclarationVariableDeclaration => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                        _,
                    ) => {
                        NonTerminal::VariableDeclaration(
                            compiler_actions::variable_declaration_variable_declaration(
                                &*context,
                                p0,
                                p1,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ConstantDeclarationConstantDeclaration => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                        _,
                    ) => {
                        NonTerminal::ConstantDeclaration(
                            compiler_actions::constant_declaration_constant_declaration(
                                &*context,
                                p0,
                                p1,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::WhileStatementWhile => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::StatementList(p1)),
                    ) => {
                        NonTerminal::WhileStatement(
                            compiler_actions::while_statement_while(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ForStatementFor => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 9usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p2)),
                        _,
                        Symbol::NonTerminal(NonTerminal::StatementList(p3)),
                    ) => {
                        NonTerminal::ForStatement(
                            compiler_actions::for_statement_for(
                                &*context,
                                p0,
                                p1,
                                p2,
                                p3,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionAdd => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_add(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionSub => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_sub(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionMul => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_mul(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionDiv => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_div(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionEquals => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_equals(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionNotEquals => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_not_equals(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionLess => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_less(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionLessOrEquals => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_less_or_equals(
                                &*context,
                                p0,
                                p1,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionGreater => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_greater(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionGreaterOrEquals => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_greater_or_equals(
                                &*context,
                                p0,
                                p1,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionAnd => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_and(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionOr => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_or(&*context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionUnaryMinus => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::Expression(p0))) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_unary_minus(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionUnaryNegation => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::Expression(p0))) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_unary_negation(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionP15 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::Expression(p0)), _) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_expression(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionP16 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Number(p0)) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_number(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionP17 => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::Expression(compiler_actions::expression_true(context))
            }
            ProdKind::ExpressionP18 => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::Expression(compiler_actions::expression_false(context))
            }
            ProdKind::ExpressionP19 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Identifier(p0)) => {
                        NonTerminal::Expression(
                            compiler_actions::expression_identifier(&*context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
        };
        self.res_stack.push(Symbol::NonTerminal(prod));
    }
}
