# rusty compiler

## Table of Contents

- [v1.0](#v10)
- [v2.0](#v20)

## v1.0
Rusty compiler v1.0 parses and evaluates expressions that support numbers, boolean values, arithmetic operators, logical operators and unary operators.

<br>

**Project architecture:**

![alt text](https://github.com/bjelicamarko/rusty/blob/main/picture.png)

<br>

- **Custom Lexer and Custom Parser** (Recursive Descent Parser) - build from scratch, AST from parser is returned as struct Expression, which is used by Semantic Analyzer.
- **Rustemo Lexer and Rustemo Parser** - generated by Rustemo library, tuned to the program's logic to return the same data structure Expression as the Custom parser, which is used by Semantic Analyzer.
- **Semantic Analyzer** - Checks types of operators and operands. For example: `true + 3` will produce an error, and diagnostics will print "Binary operator Plus is not defined for types Boolean and Integer."
- **Evaluator** - Recursively traverses the tree, computes expressions by nodes, and finally prints the result.
- **Diagnostics** - Reporting info and error messages.

**Grammar:**

```plaintext
Expression: LogicalExpression;
LogicalExpression: RelationalExpression LogicalExpressionRest;
LogicalExpressionRest: PipePipe RelationalExpression LogicalExpressionRest 
                     | EMPTY;
RelationalExpression: ArithmeticExpression RelationalExpressionRest;
RelationalExpressionRest: AmpersandAmpersand ArithmeticExpression RelationalExpressionRest
                        | EqualsEquals ArithmeticExpression RelationalExpressionRest
                        | BangEquals ArithmeticExpression RelationalExpressionRest
                        | EMPTY;
ArithmeticExpression: Term ArithmeticExpressionRest;
ArithmeticExpressionRest: Plus Term ArithmeticExpressionRest 
                        | Minus Term ArithmeticExpressionRest
                        | EMPTY;
Term: Factor TermRest;
TermRest: Mul Factor TermRest
        | Div Factor TermRest
        | EMPTY;
Factor: Bang Factor
      | OpenParenthesis Expression CloseParenthesis
      | Minus Factor
      | Number
      | True
      | False;

terminals
Number: /\d+(\.\d+)?/;
Bang: '!';
OpenParenthesis: '(';
CloseParenthesis: ')';
True: 'true';
False: 'false';
Plus: '+';
Minus: '-';
Mul: '*';
Div: '/';
AmpersandAmpersand: '&&';
PipePipe: '||';
EqualsEquals: '==';
BangEquals: '!=';
```
<br>

Potential ideas for future work:
- Assignments and variables
- Statements 
- if/else 
- Loops
- Functions
- Code generation (Propably to Assembly)

## v2.0
Rusty compiler v2.0 parses and evaluates expressions that support numbers, boolean values, arithmetic operators, logical operators, relational operators and unary operators. This version suports statements, constant variables and scoping.

What's new?
- Relational Operators
- Scoping (nested code blocks)
- Assignments
- Variable and constant declaration
- If/Else statement
- For loop
- While loop
- Usage of GLR parser
- Clearer grammar
- Web part (frontend - Angular, backend - Rocket Framework)

**Usage:**

![alt text](https://github.com/bjelicamarko/rusty/blob/main/results.JPG)

**Project architecture:**

Everything is the same except that instead of the LR parser, the **CLR parser** is now used.

**Grammar:**

```plaintext
Program: StatementList;
StatementList: OpenBrace Statement+ CloseBrace;
Statement: Assignment
           | IfStatement
           | VariableDeclaration
           | ConstantDeclaration
           | WhileStatement
           | ForStatement
           | StatementList;
Assignment: Identifier Equals Expression SemiColon {Assignment};
IfStatement: If OpenParenthesis Expression CloseParenthesis StatementList ElseClause? {IfStatement};
ElseClause: Else StatementList {ElseStatement};
VariableDeclaration: Let Identifier Equals Expression SemiColon {VariableDeclaration};
ConstantDeclaration: Const Identifier Equals Expression SemiColon {ConstantDeclaration};
WhileStatement: While OpenParenthesis Expression CloseParenthesis StatementList {While}; 
ForStatement: For OpenParenthesis Identifier Equals Expression To Expression CloseParenthesis StatementList {For};   
Expression: left=Expression '+' right=Expression {Add, 3, left}
 | left=Expression '-' right=Expression {Sub, 3, left}
 | left=Expression '*' right=Expression {Mul, 4, left}
 | left=Expression '/' right=Expression {Div, 4, left}
 | left=Expression '==' right=Expression {Equals, 2, left}
 | left=Expression '!=' right=Expression {NotEquals, 2, left}
 | left=Expression '<' right=Expression {Less, 2, left}
 | left=Expression '<=' right=Expression {LessOrEquals, 2, left}
 | left=Expression '>' right=Expression {Greater, 2, left}
 | left=Expression '>=' right=Expression {GreaterOrEquals, 2, left}
 | left=Expression '&&' right=Expression {And, 1, left}
 | left=Expression '||' right=Expression {Or, 1, left}
 | Minus Expression {UnaryMinus}
 | Bang Expression {UnaryNegation}
 | OpenParenthesis Expression CloseParenthesis
 | Number
 | True
 | False
 | Identifier;

terminals
Number: /\d+(\.\d+)?/;
Plus: '+';
Minus: '-';
Mul: '*';
Div: '/';
True: 'true';
False: 'false';
OpenParenthesis: '(';
CloseParenthesis: ')';
Bang: '!';
EqualsEquals: '==';
BangEquals: '!=';
Less: '<';
LessOrEquals: '<=';
Greater: '>';
GreaterOrEquals: '>=';
AmpersandAmpersand: '&&';
PipePipe: '||';
Identifier: /[a-zA-Z_]+/;
OpenBrace: '{';
CloseBrace: '}';
Equals: '=';
SemiColon: ';';
If: 'if';
Else: 'else';
Let: 'let';
Const: 'const';
While: 'while';
For: 'for';
To: 'to';
```
<br>

Potential ideas for future work:
- Functions
- Code generation (Propably to Assembly)
